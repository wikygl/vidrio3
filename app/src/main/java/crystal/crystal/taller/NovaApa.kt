package crystal.crystal.tallerimport android.annotation.SuppressLintimport android.content.Contextimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.widget.AdapterViewimport android.widget.ArrayAdapterimport android.widget.ImageViewimport android.widget.LinearLayoutimport android.widget.TextViewimport android.widget.Toastimport androidx.appcompat.app.AppCompatActivityimport crystal.crystal.Rimport crystal.crystal.casilla.ListaCasillaimport crystal.crystal.casilla.MapStorageimport crystal.crystal.databinding.ActivityNovaApaBindingclass NovaApa : AppCompatActivity() {    private var cliente: String = ""    private var tubo: Float = 1.5f    private var puente:String = "Múltiple"    private var grados:Int= 0    private var diseno:String=""    private var texto:String=""    private var otros: Boolean = false    private val mapListas = mutableMapOf<String, MutableList<MutableList<String>>>()    private lateinit var binding: ActivityNovaApaBinding    @SuppressLint("SetTextI18n", "ResourceAsColor")    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding= ActivityNovaApaBinding.inflate(layoutInflater)        setContentView(binding.root)        // Inicializar ivDiseno con el contenido de btNovan        binding.ivDiseno.visibility = View.VISIBLE        binding.svModelos.visibility = View.GONE        binding.ivDiseno.setImageResource(R.drawable.nn)        texto = "nn"        diseno = "ic_fichad3a"        otros = false        modelos()        cliente()        spinnerTubo()        binding.fcLayout.visibility =View.GONE        binding.btnCalcularNfcfs.setOnClickListener {            binding.txPr.text=divisiones().toString()            vidriosTexto()            /*try {                val ancho = binding.med1Nfcfs.text.toString().toFloat()                val alto=binding.med2Nfcfs.text.toString().toFloat()                val hoja= binding.hojatxtNfcfsa.text.toString().toFloat()                if (divisiones()==1){binding.hLayout.visibility=View.GONE                binding.rielLayout.visibility=View.GONE                binding.portaLayout.visibility=View.GONE}                else{binding.hLayout.visibility = View.VISIBLE                    binding.rielLayout.visibility=View.VISIBLE                    binding.portaLayout.visibility=View.VISIBLE}                if (divisiones()!=2){binding.angLayout.visibility= View.GONE}                else{binding.angLayout.visibility = View.VISIBLE}                if(alto<=hoja && divisiones()>1){binding.fcLayout.visibility=View.VISIBLE}                else{binding.fcLayout.visibility=View.GONE}                if (alto<=hoja){binding.mulLayout.visibility=View.GONE}                else{binding.mulLayout.visibility = View.VISIBLE}                if (alto<=hoja || nTe()<1){binding.tLayout.visibility=View.GONE}                else{binding.tLayout.visibility = View.VISIBLE}                if (nPuentes()==1){binding.tuboLayout.visibility= View.GONE}                else{binding.tuboLayout.visibility = View.VISIBLE}                dVisible()                //CALCULO DE MATERIALES                //CANAL U                uTexto()                // RIEL                if(divisiones()!=1){binding.txR.text = if (divisiones()==10||divisiones()==14){                    "${df1(uSuperior())} = ${nPuentes()-1}\n" +                            "${df1(uSuperior2())} = ${nPuentes()-2}"}                else{"${df1(uSuperior())} = ${nPuentes()}"}}                else{binding.txR.text = ""}                // MÚLTIPLE                binding.txP.text = if (divisiones()==10||divisiones()==14){                    "${df1(uSuperior())} = ${nPuentes()-1}\n" +                            "${df1(uSuperior2())} = ${nPuentes()-2}"}                else{"${df1(uSuperior())} = ${nPuentes()}"}                binding.tvP.text = puente                // FIJO CORREDIZO                binding.txFc.text = if (divisiones()==10||divisiones()==14){                    "${df1(uSuperior())} = ${nPuentes()-1}\n" +                            "${df1(uSuperior2())} = ${nPuentes()-2}"}                else{"${df1(uSuperior())} = ${nPuentes()}"}                // HACHE                binding.txH.text = "${df1(hache())} = ${nCorredizas()}"                // PORTAFELPA                binding.txPf.text = when {                    divisiones() == 1 -> ""                    divisiones() % 2 == 0 && divisiones() < 6 -> "${df1(portafelpa())} = ${nCorredizas() * 3}"                    divisiones() % 2 == 0 && divisiones() > 6 -> "${df1(portafelpa())} = ${divDePortas()}"                    else -> "${df1(portafelpa())} = ${nCorredizas() * 4}"                }                // TE                binding.txTe.text = "${df1(te())} = ${nTe()}"                //ÁNGULO TOPE                binding.txTo.text= if (divisiones() == 2){"${df1(altoHoja()-0.3f)} = 1"}else{""}                //PARANTE                binding.txT.text =if (divisiones() % 2==0&&divisiones()>=6)                {"${df1(parante())} = ${nPuentes()-1}"} else{""}                //VIDRIOS                binding.txV.text = if(hoja<alto){if(divisiones()>1)                {"${vidriosFijos()}\n${vidrioCorre()}\n${vidrioMocheta()}"}                    else{"${vidriosFijos()}\n${vidrioMocheta()}"}}                else{if(divisiones()>1){"${vidriosFijos()}\n${vidrioCorre()}"}                    else{vidriosFijos()}}                // REFERENCIAS                binding.txReferencias.text="An: ${df1(ancho)}  x  Al: $alto\nAltura de puente:${                    df1(altoHoja())}\nDivisiones:" +                        " ${divisiones()} -> fjs: ${nFijos()};czs: ${nCorredizas()}\nDiseño: ${dVisible()}"                // ANCHO                binding.txAncho.text= "${df1(ancho)} = 0r"                binding.txAlto.text= "${alto()} = 0r"                binding.txPuente.text= "${df1(altoHoja())} = 1r"                binding.txDivisiones.text= "${df1(divisiones().toFloat())} = ${df1(divisiones().toFloat())}r "                binding.txFijos.text= "${df1(nFijos().toFloat())} = ${df1(nFijos().toFloat())}r"                binding.txCorredizas.text= "${df1(nCorredizas().toFloat())} = ${df1(nCorredizas().toFloat())}r"                binding.txDiseno.text= "${dVisible()} = 0r"                binding.txGrados.text="$grados = 1g"                binding.txTipo.text = "nova aparente = 0g"                binding.txC.text = "$cliente = 0e"                binding.tvPr.text= grados.toString()                binding.txPr.text = texto            } catch (e: Exception) {                Toast.makeText(this, "Ingrese dato válido", Toast.LENGTH_SHORT).show()}*/        }        binding.btArchivar.setOnClickListener {            archivarMapas()        }        binding.btnCalcularNfcfs.setOnLongClickListener {            // Cargar el Map guardado            val mapListas = MapStorage.cargarMap(this)            // Verificar si el Map está vacío o nulo            if (!mapListas.isNullOrEmpty()) {                // Mostrar el Map en txPr                binding.etCruce.setText(mapListas.toString())                Toast.makeText(this, "Map cargado correctamente", Toast.LENGTH_SHORT).show()            } else {                // Si no hay datos guardados, mostrar un mensaje                //binding.txPr.text = "No hay datos guardados"                Toast.makeText(this, "No se encontró un Map guardado", Toast.LENGTH_SHORT).show()            }            true // Retorna true para indicar que el evento fue manejado        }        binding.btArchivar.setOnLongClickListener {            // Llamar a la función para guardar el Map            MapStorage.guardarMap(this, mapListas)            // Mostrar un mensaje de confirmación            Toast.makeText(this, "Map guardado correctamente", Toast.LENGTH_SHORT).show()            true // Retorna true para indicar que el evento fue manejado        }        /*binding.ivDiseno.setOnClickListener {            //startActivity(Intent(this, FichaActivity::class.java))        }*/        binding.ivDiseno.setOnLongClickListener { view ->            // Rotar el ImageView 180 grados con una animación de 500ms            view.animate().rotationBy(180f).setDuration(500).start()            // Actualizar el valor de grados            grados = (grados + 180) % 360            // Opcional: Mostrar el valor actualizado en un Toast            Toast.makeText(this, "Grados: $grados", Toast.LENGTH_SHORT).show()            true // Indica que el evento ha sido manejado        }        binding.txHpuente.setOnLongClickListener {            mostrarLySpinner()            true        }        binding.btOk.setOnClickListener {            ocultarLySpinner()        }    }    @SuppressLint("SetTextI18n")    private fun cliente(){        binding.lyCliente.visibility=View.GONE        val paqueteR=intent.extras        //VARIABLES DE MATERIALES        var cliente= paqueteR?.getString("rcliente")        if (cliente!=null) {binding.tvTitulo.text= "nova aparente $cliente"}        else  {binding.tvTitulo.text= "nova aparente"}        if (cliente!=null) {cliente= "nova aparente $cliente"}        else  {binding.txC.text= "nova aparente"}        binding.tvTitulo.setOnClickListener {            binding.lyCliente.visibility=View.VISIBLE            binding.clienteEditxt.setText("$cliente")            binding.btGo.setOnClickListener {                cliente = binding.clienteEditxt.text.toString()                binding.tvTitulo.text="nova aparente $cliente"                cliente= "nova aparente $cliente"                binding.lyCliente.visibility=View.GONE }        }    }    private fun modelos() {        binding.btNovan.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.ic_fichad3a)            texto = "nn"            diseno = "ic_fichad3a"            otros = false // Permitir que dVisible() ejecute su lógica        }        binding.btNovacc.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacc)            texto = "ncc"            diseno = "novacc"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNova3c.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.nova3c)            texto = "n3c"            diseno = "nova3c"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNovacfc.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacfc)            texto = "ncfc"            diseno = "novacfc"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNoval.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.noval)            texto = "nl"            diseno = "pv"            binding.lyAncho2.visibility = View.VISIBLE            otros = true // Ignorar la lógica de dVisible()        }        binding.btNovau.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novau)            texto = "nu"            diseno = "pvv"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNovas.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novas)            texto = "ns"            diseno = "pvv"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNovacu.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacu)            texto = "ncu"            diseno = "pvv"            otros = true // Ignorar la lógica de dVisible()        }        binding.btNovaci.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novaci)            texto = "nci"            diseno = "pvv"            otros = true // Ignorar la lógica de dVisible()        }        binding.ivDiseno.setOnClickListener {            binding.ivDiseno.visibility = View.GONE            binding.svModelos.visibility = View.VISIBLE            binding.lyAncho2.visibility = View.GONE            otros = false                    }    }    private fun dVisible(): String {        if (otros) {            // Si debemos ignorar dVisible, no hacemos nada            return ""        }        val alto = divisiones().toString()        val hoja = if (siNoMoch() == 1) { "" } else { "c" }.toString()        texto = "$alto$hoja"        val drawableResource = when (texto) {            "1" -> R.drawable.ic_fichad1a            "1c" -> R.drawable.ic_fichad1            "2" -> R.drawable.ic_fichad2a            "2c" -> R.drawable.ic_fichad2c            "3" -> R.drawable.ic_fichad3a            "3c" -> R.drawable.ic_fichad3c            "4" -> R.drawable.ic_fichad4a            "4c" -> R.drawable.ic_fichad4c            "5" -> R.drawable.ic_fichad5a            "5c" -> R.drawable.ic_fichad5c            "6" -> R.drawable.ic_fichad6a            "6c" -> R.drawable.ic_fichad6c            "7" -> R.drawable.ic_fichad7a            "7c" -> R.drawable.ic_fichad7c            "8" -> R.drawable.ic_fichad8a            "8c" -> R.drawable.ic_fichad8c            "9" -> R.drawable.ic_fichad9a            "9c" -> R.drawable.ic_fichad9c            "10" -> R.drawable.ic_fichad10a            "10c" -> R.drawable.ic_fichad10c            "11" -> R.drawable.ic_fichad11a            "11c" -> R.drawable.ic_fichad11c            "12" -> R.drawable.ic_fichad12a            "12c" -> R.drawable.ic_fichad12c            "13" -> R.drawable.ic_fichad13a            "13c" -> R.drawable.ic_fichad13c            "14" -> R.drawable.ic_fichad14a            "14c" -> R.drawable.ic_fichad14c            "15" -> R.drawable.ic_fichad15a            "15c" -> R.drawable.ic_fichad15c            else -> R.drawable.ic_fichad5        }        // Cargar el drawable en el ImageView usando ViewBinding        binding.ivDiseno.setImageResource(drawableResource)        // Retornar el nombre del drawable        return when (texto) {            "1" -> "ic_fichad1a"            "1c" -> "ic_fichad1"            "2" -> "ic_fichad2a"            "2c" -> "ic_fichad2c"            "3" -> "ic_fichad3a"            "3c" -> "ic_fichad3c"            "4" -> "ic_fichad4a"            "4c" -> "ic_fichad4c"            "5" -> "ic_fichad5a"            "5c" -> "ic_fichad5c"            "6" -> "ic_fichad6a"            "6c" -> "ic_fichad6c"            "7" -> "ic_fichad7a"            "7c" -> "ic_fichad7c"            "8" -> "ic_fichad8a"            "8c" -> "ic_fichad8c"            "9" -> "ic_fichad9a"            "9c" -> "ic_fichad9c"            "10" -> "ic_fichad10a"            "10c" -> "ic_fichad10c"            "11" -> "ic_fichad11a"            "11c" -> "ic_fichad11c"            "12" -> "ic_fichad12a"            "12c" -> "ic_fichad12c"            "13" -> "ic_fichad13a"            "13c" -> "ic_fichad13c"            "14" -> "ic_fichad14a"            "14c" -> "ic_fichad14c"            "15" -> "ic_fichad15a"            "15c" -> "ic_fichad15c"            else -> "ic_fichad5"        }    }    // FUNCIONES REDONDEOS    private fun df1(defo: Float): String {        return if (defo % 1 == 0f) {            // Si es un número entero, muestra sin decimales            defo.toInt().toString()        } else {            // Si tiene decimales, formatea con un decimal            "%.1f".format(defo).replace(",", ".")        }    }    // FUNCIONES DATOS    private fun cruce(): Float {        val exacto = binding.etCruce.text.toString().toFloat()        val cruce = 0.7f        return if (exacto == 0f) {cruce} else {exacto}    }    // FUNCIONES U    private fun uFijos(): Float {        val ancho = binding.med1Nfcfs.text.toString().toFloat()        val cruce = when(divisiones()){            2,3,5,7,9,11,13,15 -> divisiones()-1            4,6,10 -> divisiones()-2            8,12 -> divisiones()/2            14 -> divisiones()-4            else -> divisiones()-1}*cruce()        val partes= ((ancho-(2.5*(nPuentes()-1)))+cruce)/divisiones()        return if (divisiones()==1){ancho}else{partes.toFloat()}    }    private fun uParante():Float {        val us = binding.etU.text.toString().toFloat()        return altoHoja()-(us+0.2f)    }    private fun uMocheta():Float {        val us = binding.etU.text.toString().toFloat()        return altoMocheta()-(us)    }    private fun uSuperior(): Float {        return mPuentes1()    }    private fun uSuperior2(): Float {        return mPuentes2()    }    @SuppressLint("SetTextI18n")    private fun uTexto(){        val us = binding.etU.text.toString().toFloat()        val alto=binding.med2Nfcfs.text.toString().toFloat()        val hoja= binding.hojatxtNfcfsa.text.toString().toFloat()        val valorFinal = if (puente == "Múltiple" || puente == "gorrito") 1 else 2        when (binding.etU.text.toString().toFloat()) {            1f -> {                binding.tvU.text= "u-3/8"            }            1.5f -> {                binding.tvU.text= "u-13"            }            else -> {                binding.tvU.text= "u-${df1(us)}"            }        }        when (texto){            "nn" -> if (alto > hoja && us != 0F) {                binding.txU.text = when {                    divisiones() == 1 -> "${df1(uFijos())} = 2\n" +                            "${df1(uParante())} = 2\n${df1(uMocheta())} = ${mochetaUParante()}"                    divisiones() == 10 || divisiones() == 14 -> "${df1(uFijos())} = ${nFijos()}\n" +                            "${df1(uParante())} = ${fijoUParante()}\n${df1(uMocheta())} = ${mochetaUParante()}\n" +                            "${df1(uSuperior())} = ${nPuentes()-1}\n${df1(uSuperior2())} = ${(nPuentes()-2)*valorFinal}"                    else -> "${df1(uFijos())} = ${nFijos()}\n${df1(uParante())} = ${fijoUParante()}\n" +                            "${df1(uMocheta())} = ${mochetaUParante()}\n${df1(uSuperior())} = ${nPuentes()*valorFinal}"                }            } else if (alto > hoja && us == 0F) {                binding.txU.text = when {                    divisiones() == 1 -> "${df1(uFijos())} = 2"                    divisiones() == 10 || divisiones() == 14 -> "${df1(uFijos())} = ${nFijos()}\n${df1(uSuperior())} = ${nPuentes()-1}\n${df1(uSuperior2())} = ${nPuentes()-2}"                    else -> "${df1(uFijos())} = ${nFijos()}\n${df1(uSuperior())} = ${nPuentes()}"                }            } else if (alto <= hoja && us != 0F) {                binding.txU.text = when {                    divisiones() == 1 -> "${df1(uFijos())} = 2\n${df1(uParante())} = 2"                    else -> "${df1(uFijos())} = ${nFijos()}\n${df1(uParante())} = ${fijoUParante()}"                }            } else {                binding.txU.text = when {                    divisiones() == 1 -> "${df1(uFijos())} = 2"                    else -> "${df1(uFijos())} = ${nFijos()}"                }            }            "ncc" -> "${df1(uMocheta())} = ${mochetaUParante()}\\n${df1(uSuperior())} = ${nPuentes() * valorFinal}"        }    }    // FUNCIONES otros perfiles    private fun portafelpa():Float {        return altoHoja()-1.6f    }    private fun hache():Float {        return uFijos()    }    private fun te():Float {        val us = binding.etU.text.toString().toFloat()        return altoMocheta()-(us)    }    private fun nTe():Int{       return when{            divisiones()%2 !=0 || divisiones()<6 -> nVidriosMoch()-1            divisiones() == 6 || divisiones()== 8 -> nVidriosMoch()-2            divisiones() == 10 || divisiones() == 14 -> (nVidriosMoch()-2)+(nVidriosMoch2()-1)            divisiones() == 12 -> (nVidriosMoch()-3)            else -> {0}        }    }    private fun parante(): Float {        return binding.med2Nfcfs.text.toString().toFloat()    }    //FUNCIONES vidrios    private fun vidriosFijos():String{        val alto=altoHoja()        val us = binding.etU.text.toString().toFloat()        val holgura = if (us==0f){1f}else{0.2f}        return when {            divisiones()==1-> {"${df1(uFijos()-0.6f)} x ${df1(alto-(us+holgura))} = " +                    "${nFijos()}"}            divisiones()<5 -> {"${df1(uFijos()-0.4f)} x ${df1(alto-(us+holgura))} = " +                    "${nFijos()}"}            divisiones()%2==0 && divisiones()<14 -> {"${df1(uFijos()-0.4f)} x " +                    "${df1(alto-(us+holgura))} = ${nFijos()}"}            divisiones()==14 -> {"${df1(uFijos()-0.4f)} x ${df1(alto-(us+holgura))} = 6\n" +                    "${df1(uFijos())} x ${df1(alto-(us+holgura))} = 2"}            else -> {"${df1(uFijos()-0.4f)} x ${df1(alto-(us+holgura))} = 2\n" +                    "${df1(uFijos())} x ${df1(alto-(us+holgura))}= ${nFijos()-2}"}}    }    private fun vidrioCorre():String {        return "${df1(hache()-1.4f)} x ${df1(altoHoja()-3.5f)} = ${nCorredizas()}"    }    private fun vidrioMocheta():String {        return if(divisiones()==1){df1(vAnchoMocheta1()) +                " x ${df1(vAltoMocheta())} = ${anchMota()}"}        else if (divisiones()==10||divisiones()==14){"${df1(vAnchoMocheta1())} x ${            df1(vAltoMocheta())} = ${nVidriosMoch()}\n" +                "${df1(vidrioAnchoMocheta2())} x ${                    df1(vAltoMocheta())} = ${nVidriosMoch2()}"}        else{"${df1(vAnchoMocheta1())} x ${            df1(vAltoMocheta())} = ${nVidriosMoch()}"}    }    private fun vAltoMocheta(): Float {        val us = binding.etU.text.toString().toFloat()        val holgura=0.36f        return if (puente=="Múltiple"||puente=="gorrito") {            altoMocheta() - holgura        }else{altoMocheta()-us-holgura}    }    private fun vAnchoMocheta1():Float {        val holgura=if(divisiones()%2==0){((nVidriosMoch()+1)*0.36f)/2}else{(nVidriosMoch()+1)*0.36f}        return (mPuentes1()-holgura)/anchMota()    }    private fun vidrioAnchoMocheta2():Float {        val holgura=(nVidriosMoch2()+1)*0.36f        return (mPuentes2()-holgura)/anchMota2()    }    private fun nVidriosMoch(): Int {        return if (divisiones() == 2 && divisiones() == 4) {anchMota()}        else if (divisiones() % 2 == 0 && divisiones() >= 6 && divisiones() < 10) {anchMota() * 2}        else if (divisiones() == 12) {anchMota() * 3}        else if (divisiones() == 10 || divisiones() == 14) {anchMota() * 2}        else {anchMota()}    }    private fun nVidriosMoch2(): Int {        return if (divisiones() == 10 || divisiones() == 14) {anchMota2()}        else {1}    }    @SuppressLint("SetTextI18n")    private fun vidriosTexto() {        val alto=binding.med2Nfcfs.text.toString().toFloat()        val hoja= binding.hojatxtNfcfsa.text.toString().toFloat()        when (texto){            "nn" -> binding.txV.text = if(hoja<alto){if(divisiones()>1)            {"${vidriosFijos()}\n${vidrioCorre()}\n${vidrioMocheta()}"}            else{"${vidriosFijos()}\n${vidrioMocheta()}"}}            else{if(divisiones()>1){"${vidriosFijos()}\n${vidrioCorre()}"}            else{vidriosFijos()}}            "ncc","n3c" -> binding.txV.text = if(hoja<alto){"${vidrioCorre()}\n${vidrioMocheta()}" } else {                vidrioCorre() }            "ncfc" -> binding.txV.text = if(hoja<alto){"${vidriosFijos()}\n${vidrioCorre()}\n${vidrioMocheta()}"}else {                "${vidriosFijos()}\n${vidrioCorre()}" }            "nl" -> binding.txV.text = if(hoja<alto){if(divisiones()>1)            {"${vidriosFijos()}\n${vidrioCorre()}\n${vidrioMocheta()}"}            else{"${vidriosFijos()}\n${vidrioMocheta()}"}}            else{if(divisiones()>1){"${vidriosFijos()}\n${vidrioCorre()}"}            else{vidriosFijos()}}            "nu" -> binding.txV.text = ""            "ns" -> binding.txV.text = ""            "ncu" -> binding.txV.text = ""            "nci" -> binding.txV.text = ""            else -> {binding.txV.text =""}        }    }    //FUNCIONES REFERENCIAS    private fun ancho(): String {        return df1(binding.med1Nfcfs.text.toString().toFloat())    }    private fun ancho2(): String {        return df1(binding.etAncho2.text.toString().toFloat())    }    private fun alto(): String {        return df1(binding.med2Nfcfs.text.toString().toFloat())    }    //FUNCIONES DE ARCHIVO    private fun archivarMapas() {        ListaCasilla.incrementarContadorVentanas()        // Caso especial para txReferencias        if (esValido(binding.lyReferencias)) {            ListaCasilla.procesarReferencias(binding.tvReferencias, binding.txReferencias, mapListas) // referencias        }        // Usar la clase ListaCasilla para procesar y archivar solo los TextView válidos        if (esValido(binding.u13layout)) {            ListaCasilla.procesarArchivar(binding.tvU, binding.txU, mapListas) // u        }        if (esValido(binding.mulLayout)) {            ListaCasilla.procesarArchivar(binding.tvP, binding.txP, mapListas) // puente        }        if (esValido(binding.fcLayout)) {            ListaCasilla.procesarArchivar(binding.tvFc, binding.txFc, mapListas) // fijo corredizo        }        if (esValido(binding.rielLayout)) {            ListaCasilla.procesarArchivar(binding.tvR, binding.txR, mapListas) // riel        }        if (esValido(binding.tuboLayout)) {            ListaCasilla.procesarArchivar(binding.tvT, binding.txT, mapListas) // tubo        }        if (esValido(binding.portaLayout)) {            ListaCasilla.procesarArchivar(binding.tvPf, binding.txPf, mapListas) // portafelpa        }        if (esValido(binding.tLayout)) {            ListaCasilla.procesarArchivar(binding.tvTe, binding.txTe, mapListas) // tee        }        if (esValido(binding.angLayout)) {            ListaCasilla.procesarArchivar(binding.tvTo, binding.txTo, mapListas) // tope        }        if (esValido(binding.hLayout)) {            ListaCasilla.procesarArchivar(binding.tvH, binding.txH, mapListas) // h        }        if (esValido(binding.vidriosLayout)) {            ListaCasilla.procesarArchivar(binding.tvV, binding.txV, mapListas) // vidrios        }        if (esValido(binding.lyClient)) {            ListaCasilla.procesarArchivar(binding.tvC, binding.txC, mapListas) // cliente        }        if (esValido(binding.lyAncho)) {            ListaCasilla.procesarArchivar(binding.tvAncho, binding.txAncho, mapListas) // ancho        }        if (esValido(binding.lyAlto)) {            ListaCasilla.procesarArchivar(binding.tvAlto, binding.txAlto, mapListas) // alto        }        if (esValido(binding.lyPuente)) {            ListaCasilla.procesarArchivar(binding.tvPuente, binding.txPuente, mapListas) // altura Puente        }        if (esValido(binding.lyDivisiones)) {            ListaCasilla.procesarArchivar(binding.tvDivisiones, binding.txDivisiones, mapListas) // divisiones        }        if (esValido(binding.lyFijos)) {            ListaCasilla.procesarArchivar(binding.tvFijos, binding.txFijos, mapListas) // nFijos        }        if (esValido(binding.lyCorredizas)) {            ListaCasilla.procesarArchivar(binding.tvCorredizas, binding.txCorredizas, mapListas) // nCorredizas        }        if (esValido(binding.lyDiseno)) {            ListaCasilla.procesarArchivar(binding.tvDiseno, binding.txDiseno, mapListas) // diseño        }        if (esValido(binding.lyGrados)) {            ListaCasilla.procesarArchivar(binding.tvGrados, binding.txGrados, mapListas) // grados        }        if(esValido(binding.lyTipo)){            ListaCasilla.procesarArchivar(binding.tvTipo,binding.txTipo,mapListas) // tipo de ventana        }        // Aquí puedes hacer algo con `mapListas`, como mostrarlo o guardarlo        binding.txPr.text = mapListas.toString()        println(mapListas)    }    // Función para verificar si un Layout es visible o tiene estado GONE    private fun esValido(ly: LinearLayout): Boolean {        return ly.visibility == View.VISIBLE || ly.visibility == View.INVISIBLE    }    //FUNCIONES CONSTANTES    private fun altoMocheta():Float {        val alto= binding.med2Nfcfs.text.toString().toFloat()        val hoja= binding.hojatxtNfcfsa.text.toString().toFloat()        return if (hoja==0f){(alto/7*2)-tubo}else if(hoja==alto){alto}else{(alto-hoja)-tubo}    }    private fun anchMota(): Int {        return when (mPuentes1()) {            in 0.0..180.0 -> 1            in 180.0..360.0 -> 2            in 360.0..540.0 -> 3            in 540.0..720.0 -> 4            in 720.0..900.0 -> 5            else -> 0}    }    private fun anchMota2(): Int {        return when (mPuentes2()) {            in 0.0..180.0 -> 1            in 180.0..360.0 -> 2            in 360.0..540.0 -> 3            in 540.0..720.0 -> 4            in 720.0..900.0 -> 5            else -> 0}    }    private fun altoHoja():Float {        val alto=binding.med2Nfcfs.text.toString().toFloat()        val hoja= binding.hojatxtNfcfsa.text.toString().toFloat()        val corre = if (hoja>=alto){alto}else{hoja}        return if (hoja==0f){alto/7*5}else{corre}    }    private fun siNoMoch(): Int {        val alto = binding.med2Nfcfs.text.toString().toFloat()        val hoja = binding.hojatxtNfcfsa.text.toString().toFloat()        return if (hoja >= alto) {0} else {1}    }    private fun divisiones(): Int {        val ancho = binding.med1Nfcfs.text.toString().toFloat()        val divis = binding.partesNfcfs.text.toString().toInt()        return when (texto) {            "nn" -> return if (divis == 0) {                when {                    ancho <= 60 -> 1                    ancho in 60.0..120.0 -> 2                    ancho in 120.0..180.0 -> 3                    ancho in 180.0..240.0 -> 4                    ancho in 240.0..300.0 -> 5                    ancho in 300.0..360.0 -> 6                    ancho in 360.0..420.0 -> 7                    ancho in 420.0..480.0 -> 8                    ancho in 480.0..540.0 -> 9                    ancho in 540.0..600.0 -> 10                    ancho in 600.0..660.0 -> 11                    ancho in 660.0..720.0 -> 12                    ancho in 720.0..780.0 -> 13                    ancho in 780.0..840.0 -> 14                    ancho in 840.0..900.0 -> 15                    else -> divis                }            } else {                divis            }            "ncc" -> return 2            "n3c","ncfc" -> return 3            "ncfc" -> return 3            else -> {0}        }    }    private fun divDePortas(): Int {        return when (divisiones()){            1 ->0            2,4,8,12 -> {nCorredizas()*3}            14 -> {(nCorredizas()*4)-2}            else->{nCorredizas()*4}        }    }    private fun nFijos():Int {        return when (texto) {            "nn"-> when (divisiones()){            1 -> 1  2 -> 1            3 -> 2  4 -> 2            5 -> 3            6 -> 4  7 -> 4            8 -> 4            9 -> 5            10 ->6  11 -> 6  12 -> 6            13 ->7  14 ->8   15 -> 8            else -> 0        }            "ncc" -> 0            "n3c" -> 0            "ncfc" -> 1            else -> {0}        }    }    private fun nCorredizas():Int {        return when (texto) {            "nn"-> when (divisiones()){                1 -> 0                2 -> 1   3 -> 1                4 -> 2   5 -> 2   6 -> 2                7 -> 3                8 -> 4   9 -> 4   10 -> 4                11-> 5                12-> 6   13-> 6   14 -> 6                15-> 7                else -> 0            }            "ncc" -> 2            "n3c" -> 3            "ncfc" -> 2            else -> {0}        }    }    private fun fijoUParante():Int{        return when (divisiones()){            1 -> 2   2 -> 1   3 -> 2    4 -> 2    5 -> 2            6 -> 4   7 -> 2   8 -> 4    9 -> 2    10 -> 6            11 -> 2  12 -> 6  13 -> 2   14 -> 6   15 -> 2            else -> 0        }    }    private fun mochetaUParante():Int {        return when (divisiones()){            1 -> 2   2 -> 2   3 -> 2    4 -> 2    5 -> 2            7 -> 2   9 -> 2   11 -> 2   13 -> 2   15 -> 2            6 -> 4   8 -> 4   10 -> 6   12 -> 6   14 -> 6            else -> 0        }    }    private fun nPuentes():Int {        return when (divisiones()){            1 -> 1   2 -> 1   3 -> 1    4 -> 1    5 -> 1            7 -> 1   9 -> 1   11 -> 1   13 -> 1   15 -> 1            6 -> 2   8 -> 2  10 -> 3   12 -> 3   14 -> 3            else -> 0        }    }    private fun mPuentes1():Float {        val ancho = binding.med1Nfcfs.text.toString().toFloat()        val parantes=2.5f        return when (divisiones()){            1 -> ancho   2 -> ancho   3 -> ancho    4 -> ancho    5 -> ancho            7 -> ancho  9 -> ancho   11 -> ancho   13 -> ancho   15 -> ancho            6 -> (ancho-parantes)/2   8 -> (ancho-parantes)/2  10 -> (ancho-(2*parantes))/divisiones()*3            12 -> (ancho-(2*parantes))/3   14 -> (ancho-(2*parantes))/divisiones()*5            else -> 0f        }    }    private fun mPuentes2():Float {        val ancho = binding.med1Nfcfs.text.toString().toFloat()        val parantes=2.5f        return when (divisiones()){            10 -> (ancho-(2*parantes))/divisiones()*4            14 -> (ancho-(2*parantes))/divisiones()*4            else -> 0f        }    }    //FUNIONES TUBO SPINNER    private fun spinnerTubo() {        val spinnerOptions = listOf(            SpinnerTubos(R.drawable.ma_multi,"Múltiple", 1.5f),            SpinnerTubos(R.drawable.ma_multi,"tubo 2 x 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi,"tubo 2 3|8 x 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi,"tubo.c 1 1|2", 3.8f),            SpinnerTubos(R.drawable.ma_multi,"tubo.c 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi,"paflon 1 1|2", 3.8f),            SpinnerTubos(R.drawable.ma_multi,"paflon 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi,"tubo 2 x 2", 5.0f),            SpinnerTubos(R.drawable.ma_multi,"gorrito", 2.5f)            // Agrega más opciones según sea necesario        )        val adapter = AdaptadorSpinner(this, spinnerOptions)        binding.spinner.adapter = adapter        binding.spinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {            override fun onItemSelected(                parent: AdapterView<*>?,                view: View?,                position: Int,                id: Long            ) {                val selectedOption = spinnerOptions[position]                tubo = selectedOption.valor                puente = selectedOption.text                Toast.makeText(                    this@NovaApa,                    "Seleccionado: ${selectedOption.text}, Valor: ${selectedOption.valor}",                    Toast.LENGTH_SHORT                ).show()            }            override fun onNothingSelected(parent: AdapterView<*>?) {                // Opcional: manejar el caso cuando no se selecciona nada            }        }    }    private fun mostrarLySpinner() {        binding.lySpinner.alpha = 0f        binding.lySpinner.visibility = View.VISIBLE        binding.lySpinner.animate()            .alpha(1f)            .setDuration(300)            .start()    }    private fun ocultarLySpinner() {        binding.lySpinner.animate()            .alpha(0f)            .setDuration(300)            .withEndAction {                binding.lySpinner.visibility = View.GONE            }            .start()    }    //CLASES RELACIONADOS    data class SpinnerTubos(        val imageResId: Int,        val text: String,        val valor:Float    )    class AdaptadorSpinner(        context: Context,        private val options: List<SpinnerTubos>    ) : ArrayAdapter<SpinnerTubos>(context, 0, options) {        override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {            return createItemView(position, convertView, parent)        }        override fun getDropDownView(position: Int, convertView: View?, parent: ViewGroup): View {            return createItemView(position, convertView, parent)        }        private fun createItemView(position: Int, convertView: View?, parent: ViewGroup): View {            val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.mo_tubo, parent, false)            val imageViewOption = view.findViewById<ImageView>(R.id.imgTubo)            val textViewOption = view.findViewById<TextView>(R.id.txNombre)            val spinnerOption = options[position]            imageViewOption.setImageResource(spinnerOption.imageResId)            textViewOption.text = spinnerOption.text            return view        }    }}