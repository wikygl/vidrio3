package crystal.crystal.taller.novaimport android.annotation.SuppressLintimport android.content.Contextimport android.content.Intentimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Menuimport android.view.MenuItemimport android.view.Viewimport android.view.ViewGroupimport android.widget.AdapterViewimport android.widget.ArrayAdapterimport android.widget.ImageViewimport android.widget.TextViewimport android.widget.Toastimport androidx.activity.result.contract.ActivityResultContractsimport androidx.appcompat.app.AppCompatActivityimport crystal.crystal.Diseno.nova.DisenoNovaActivityimport crystal.crystal.Rimport crystal.crystal.casilla.DialogosProyectoimport crystal.crystal.casilla.ListaCasillaimport crystal.crystal.casilla.MapStorageimport crystal.crystal.casilla.ProyectoManagerimport crystal.crystal.casilla.ProyectoUIHelperimport crystal.crystal.databinding.ActivityNovaApaBindingimport crystal.crystal.taller.nova.NovaUIHelper.esValidoimport kotlin.math.ceilclass NovaApa : AppCompatActivity() {    private var cliente: String = ""    private var tubo: Float = 1.5f    private var puente: String = "MÃºltiple"    private var grados: Int = 0    private var diseno: String = ""    private var texto: String = ""    private var otros: Boolean = false    private var contadorLado = 1    private var maxLados = -1    private val mapListas = mutableMapOf<String, MutableList<MutableList<String>>>()    private var primerClickArchivarRealizado = false    private val lanzarDiseno = registerForActivityResult(        ActivityResultContracts.StartActivityForResult()    ) { res ->        if (res.resultCode == RESULT_OK) {            val uri = res.data?.data ?: return@registerForActivityResult            if (uri.toString().endsWith(".svg")) {                // Mostrar SVG (vector) en el ImageView                val input = contentResolver.openInputStream(uri)!!                val svg = com.caverock.androidsvg.SVG.getFromInputStream(input)                val picture = svg.renderToPicture()                val drawable = android.graphics.drawable.PictureDrawable(picture)                // Importante: deshabilitar HW para PictureDrawable                binding.ivDiseno.setLayerType(View.LAYER_TYPE_SOFTWARE, null)                binding.ivDiseno.scaleType = ImageView.ScaleType.FIT_CENTER                binding.ivDiseno.setImageDrawable(drawable)            } else {                // PNG                binding.ivDiseno.setImageURI(uri)            }        }    }    private lateinit var binding: ActivityNovaApaBinding        // ==================== VARIABLES PARA SISTEMA DE PROYECTOS ====================    private lateinit var proyectoCallback: DialogosProyecto.ProyectoCallback    @SuppressLint("SetTextI18n", "ResourceAsColor")    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        binding = ActivityNovaApaBinding.inflate(layoutInflater)        setContentView(binding.root)        ProyectoManager.inicializarDesdeStorage(this)        proyectoCallback = ProyectoUIHelper.crearCallbackConActualizacionUI(            context = this,            textViewProyecto = binding.tvProyectoActivo,            activity = this        )        ProyectoUIHelper.configurarVisorProyectoActivo(this, binding.tvProyectoActivo)        procesarIntentProyecto(intent)        // ==================== CONFIGURACIÃ“N ORIGINAL ====================        texto = "nn"        diseno = "ic_fichad3a"        otros = false        modelos()        cliente()        spinnerTubo()        binding.fcLayout.visibility = View.GONE        calcular()        binding.btArchivar.setOnClickListener {            // Validar que se hayan ingresado nuevos datos antes de archivar            if (binding.etAncho.text.toString().isEmpty() || binding.etAncho.text.toString() == "") {                Toast.makeText(this, "Haz nuevo cÃ¡lculo", Toast.LENGTH_SHORT).show()                return@setOnClickListener            }            if (!primerClickArchivarRealizado) {                // Primera vez - mostrar diÃ¡logo                DialogosProyecto.mostrarDialogoSeleccionarParaArchivar(this, object : DialogosProyecto.ProyectoCallback {                    override fun onProyectoSeleccionado(nombreProyecto: String) {                        primerClickArchivarRealizado = true                        // CARGAR Map existente del proyecto seleccionado                        val mapExistente = MapStorage.cargarProyecto(this@NovaApa, nombreProyecto)                        if (mapExistente != null) {                            mapListas.clear()                            mapListas.putAll(mapExistente)                        }                        archivarMapas()                        ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                        Toast.makeText(this@NovaApa, "Archivado", Toast.LENGTH_SHORT).show()                        binding.etAncho.setText("")                        binding.etAlto.setText("")                    }                    override fun onProyectoCreado(nombreProyecto: String) {                        primerClickArchivarRealizado = true                        // Para proyecto nuevo, Map inicia vacÃ­o (correcto)                        archivarMapas()                        ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                        Toast.makeText(this@NovaApa, "Archivado", Toast.LENGTH_SHORT).show()                        binding.etAncho.setText("")                        binding.etAlto.setText("")                    }                    override fun onProyectoEliminado(nombreProyecto: String) {                        ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                    }                })            } else {                // Verificar que hay proyecto activo antes de archivar directamente                if (!ProyectoManager.hayProyectoActivo()) {                    // Si no hay proyecto, resetear y mostrar diÃ¡logo de nuevo                    primerClickArchivarRealizado = false                    Toast.makeText(this, "No hay proyecto activo. Selecciona uno.", Toast.LENGTH_SHORT).show()                    // Volver a mostrar diÃ¡logo                    DialogosProyecto.mostrarDialogoSeleccionarParaArchivar(this, object : DialogosProyecto.ProyectoCallback {                        override fun onProyectoSeleccionado(nombreProyecto: String) {                            primerClickArchivarRealizado = true                            // CARGAR Map existente del proyecto seleccionado                            val mapExistente = MapStorage.cargarProyecto(this@NovaApa, nombreProyecto)                            if (mapExistente != null) {                                mapListas.clear()                                mapListas.putAll(mapExistente)                            }                            archivarMapas()                            ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                            Toast.makeText(this@NovaApa, "Archivado", Toast.LENGTH_SHORT).show()                            binding.etAncho.setText("")                            binding.etAlto.setText("")                        }                        override fun onProyectoCreado(nombreProyecto: String) {                            primerClickArchivarRealizado = true                            archivarMapas()                            ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                            Toast.makeText(this@NovaApa, "Archivado", Toast.LENGTH_SHORT).show()                            binding.etAncho.setText("")                            binding.etAlto.setText("")                        }                        override fun onProyectoEliminado(nombreProyecto: String) {                            ProyectoUIHelper.actualizarVisorProyectoActivo(this@NovaApa, binding.tvProyectoActivo)                        }                    })                    return@setOnClickListener                }                // Ya se realizÃ³ el primer click Y hay proyecto activo - archivar directamente                archivarMapas()                Toast.makeText(this, "Archivado", Toast.LENGTH_SHORT).show()                binding.etAncho.setText("")                binding.etAlto.setText("")            }        }        binding.btCalcular.setOnLongClickListener {            val mapListas = MapStorage.cargarMap(this)            if (!mapListas.isNullOrEmpty()) {                binding.etCruce.setText(mapListas.toString())                Toast.makeText(this, "Map cargado del proyecto: ${ProyectoManager.getProyectoActivo()}", Toast.LENGTH_SHORT).show()            } else {                Toast.makeText(this, "No se encontrÃ³ un Map guardado en el proyecto activo", Toast.LENGTH_SHORT).show()            }            true        }        binding.btCalcular.setOnLongClickListener {            val mapListas = MapStorage.cargarMap(this)            if (!mapListas.isNullOrEmpty()) {                binding.etCruce.setText(mapListas.toString())                Toast.makeText(this, "Map cargado del proyecto: ${ProyectoManager.getProyectoActivo()}", Toast.LENGTH_SHORT).show()            } else {                Toast.makeText(this, "No se encontrÃ³ un Map guardado en el proyecto activo", Toast.LENGTH_SHORT).show()            }            true        }        binding.btArchivar.setOnLongClickListener {            if (!ProyectoManager.hayProyectoActivo()) {                Toast.makeText(this, "No hay proyecto activo para guardar", Toast.LENGTH_SHORT).show()                return@setOnLongClickListener true            }            // Guardar en SharedPreferences            MapStorage.guardarMap(this, mapListas)            Toast.makeText(this, "Map guardado en proyecto: ${ProyectoManager.getProyectoActivo()}", Toast.LENGTH_SHORT).show()            ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)            true        }        binding.ivDiseno.setOnLongClickListener { view ->            view.animate().rotationBy(180f).setDuration(500).start()            grados = (grados + 180) % 360            Toast.makeText(this, "Grados: $grados", Toast.LENGTH_SHORT).show()            true        }        binding.txHpuente.setOnLongClickListener {            mostrarLySpinner()            true        }        binding.btOk.setOnClickListener {            ocultarLySpinner()        }    }    // ==================== MENÃƒÅ¡ DE OPCIONES ====================    override fun onCreateOptionsMenu(menu: Menu?): Boolean {        menu?.let { ProyectoUIHelper.agregarOpcionesMenuProyecto(it) }        return super.onCreateOptionsMenu(menu)    }    override fun onOptionsItemSelected(item: MenuItem): Boolean {        val manejado = ProyectoUIHelper.manejarSeleccionMenu(            context = this,            itemId = item.itemId,            callback = proyectoCallback,            onProyectoCambiado = {                ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)            }        )        return if (manejado) true else super.onOptionsItemSelected(item)    }    // ==================== FUNCIONES PARA RECIBIR PROYECTO DESDE MAINACTIVITY ====================    override fun onNewIntent(intent: Intent) {        super.onNewIntent(intent)        procesarIntentProyecto(intent)    }    override fun onResume() {        super.onResume()        ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)    }    private fun procesarIntentProyecto(intent: Intent) {        val nombreProyecto = intent.getStringExtra("proyecto_nombre")        val crearNuevo = intent.getBooleanExtra("crear_proyecto", false)        val descripcionProyecto = intent.getStringExtra("proyecto_descripcion") ?: ""        if (crearNuevo && !nombreProyecto.isNullOrEmpty()) {            if (MapStorage.crearProyecto(this, nombreProyecto, descripcionProyecto)) {                ProyectoManager.setProyectoActivo(this, nombreProyecto)                ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)                Toast.makeText(this, "Proyecto '$nombreProyecto' creado y activado", Toast.LENGTH_SHORT).show()            }        } else if (!nombreProyecto.isNullOrEmpty()) {            if (MapStorage.existeProyecto(this, nombreProyecto)) {                ProyectoManager.setProyectoActivo(this, nombreProyecto)                ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)                Toast.makeText(this, "Proyecto '$nombreProyecto' activado", Toast.LENGTH_SHORT).show()            }        }    }    @SuppressLint("SetTextI18n")    private fun cliente() {        binding.lyCliente.visibility = View.GONE        val paqueteR = intent.extras        var cliente = paqueteR?.getString("rcliente")        if (cliente != null) {            binding.tvTitulo.text = "nova aparente $cliente"        } else {            binding.tvTitulo.text = "nova aparente"        }        if (cliente != null) {            cliente = "nova aparente $cliente"        } else {            binding.txC.text = "nova aparente"        }        binding.tvTitulo.setOnClickListener {            binding.lyCliente.visibility = View.VISIBLE            binding.clienteEditxt.setText("$cliente")            binding.btGo.setOnClickListener {                cliente = binding.clienteEditxt.text.toString()                binding.tvTitulo.text = "nova aparente $cliente"                cliente = "nova aparente $cliente"                binding.lyCliente.visibility = View.GONE            }        }    }    private fun calcular(){        binding.btCalcular.setOnClickListener {            try {                if (!ProyectoUIHelper.verificarProyectoActivo(this, proyectoCallback)) return@setOnClickListener                // Asegurar inicializaciÃ³n                if (texto.isEmpty() || texto.isBlank()) {                    texto = "nn"                }                binding.txPr.text = divisiones().toString()                //dVisible()                uTexto()                otrosAluminios()                vidriosTexto()                referencias()                val intent = Intent(this, DisenoNovaActivity::class.java).apply {                    putExtra(DisenoNovaActivity.EXTRA_PAQUETE, disenoSimbolico())                    putExtra(DisenoNovaActivity.EXTRA_HEADLESS, true)                    putExtra(DisenoNovaActivity.EXTRA_OUTPUT_FORMAT, "svg") // ðŸ‘ˆ vector                    putExtra(DisenoNovaActivity.EXTRA_RET_PADDING_PX, 4)                }                lanzarDiseno.launch(intent)                binding.textView28.text= disenoSimbolico()            } catch (e: Exception) {                Toast.makeText(this, "Ingrese dato vÃ¡lido", Toast.LENGTH_SHORT).show()            }        }    }    @SuppressLint("SetTextI18n")    private fun modelos() {        binding.ivDiseno.visibility = View.VISIBLE        binding.svModelos.visibility = View.GONE        binding.ivDiseno.setImageResource(R.drawable.ic_fichad3a)        texto = "nn"        diseno = "ic_fichad3a"        otros = false        binding.btNovan.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.ic_fichad3a)            texto = "nn"            diseno = "ic_fichad3a"            otros = false        }        binding.btNovaP2.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.nova2p)            texto = "np"            diseno = "nova2p"            otros = false        }        binding.btNovacc.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacc)            texto = "ncc"            diseno = "novacc"            otros = true        }        binding.btNova3c.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.nova3c)            texto = "n3c"            diseno = "nova3c"            otros = true        }        binding.btNovacfc.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacfc)            texto = "ncfc"            diseno = "novacfc"            otros = true        }        binding.btNoval.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.noval)            texto = "nl"            diseno = "noval"            binding.lyAncho2.visibility = View.VISIBLE            binding.lyDivi2.visibility = View.VISIBLE            binding.lyFlecha.visibility = View.VISIBLE            maxLados = 2            contadorLado = 1            binding.tvMedidas.text = "Medidas y Cantidad\nLado$contadorLado"            binding.btAgregar.visibility = View.VISIBLE            binding.btAgregar.isEnabled = true            otros = true        }        binding.btNovau.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novau)            texto = "nu"            diseno = "novau"            maxLados = 3            contadorLado = 1            binding.tvMedidas.text = "Medidas y Cantidad\nLado$contadorLado"            binding.btAgregar.visibility = View.VISIBLE            binding.btAgregar.isEnabled = true            otros = true        }        binding.btNovas.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novas)            texto = "ns"            diseno = "novas"            maxLados = -1            contadorLado = 1            binding.tvMedidas.text = "Medidas y Cantidad\nLado$contadorLado"            binding.btAgregar.visibility = View.VISIBLE            binding.btAgregar.isEnabled = true            otros = true        }        binding.btNovacu.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novacu)            texto = "ncu"            diseno = "novacu"            binding.lyFlecha.visibility = View.VISIBLE            otros = true        }        binding.btNovaci.setOnClickListener {            binding.ivDiseno.visibility = View.VISIBLE            binding.svModelos.visibility = View.GONE            binding.ivDiseno.setImageResource(R.drawable.novaci)            texto = "nci"            diseno = "novaci"            otros = true        }        binding.ivDiseno.setOnClickListener {            binding.ivDiseno.visibility = View.GONE            binding.svModelos.visibility = View.VISIBLE            binding.lyAncho2.visibility = View.GONE            binding.lyDivi2.visibility = View.GONE            binding.lyFlecha.visibility = View.GONE            binding.tvMedidas.text = "Medidas y Cantidad"            binding.btAgregar.visibility = View.GONE            contadorLado = 1            otros = false        }    }    private fun referencias() {        val ancho = binding.etAncho.text.toString().toFloat()        val alto = binding.etAlto.text.toString().toFloat()        val hoja = binding.etHoja.text.toString().toFloat()        val divisManual = binding.etPartes.text.toString().toInt()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val altoHoja = NovaCalculos.altoHoja(alto, hoja)        val siNoMoch = NovaCalculos.siNoMoch(alto, hoja)        val nFijos = NovaCalculos.nFijos(divisiones)        val nCorredizas = NovaCalculos.nCorredizas(divisiones)        val puntosU = if (divisiones > 4) puntosU() else ""        binding.txReferencias.text = NovaUIHelper.generarReferencias(            ancho, alto, altoHoja, divisiones, nFijos, nCorredizas, siNoMoch, puntosU        )    }    private fun disenoSimbolico(): String {        val ancho = binding.etAncho.text.toString().toFloat()        val alto = binding.etAlto.text.toString().toFloat()        val hoja = binding.etHoja.text.toString().toFloat()        val divisManual = binding.etPartes.text.toString().toInt()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val altoHoja = NovaCalculos.altoHoja(alto, hoja)        val diseno = NovaUIHelper.generarDiseno(ancho,alto,altoHoja,divisiones,siNoMoch=1,texto,anchMota())        return "{nova,apa,[$diseno]}"    }    private fun df1(defo: Float): String {        return if (defo % 1 == 0f) {            defo.toInt().toString()        } else {            "%.1f".format(defo).replace(",", ".")        }    }    private fun cruce(): Float {        val exacto = binding.etCruce.text?.toString()?.toFloatOrNull() ?: 0f        val cruce = 0.7f        return if (exacto == 0f) { cruce } else { exacto }    }    private fun uFijos(): Float {        val ancho = ancho().toFloat()        val cruce = when (divisiones()) {            2, 3, 5, 7, 9, 11, 13, 15 -> divisiones() - 1            4, 6, 10 -> divisiones() - 2            8, 12 -> divisiones() / 2            14 -> divisiones() - 4            else -> divisiones() - 1        } * cruce()        val partes = ((ancho - (2.5f * (nPuentes() - 1))) + cruce) / divisiones()        return if (divisiones() == 1) { ancho } else {            partes        }    }    private fun uParante(): Float {        val us = binding.etU.text.toString().toFloat()        return altoHoja() - (us + 0.2f)    }    private fun uMocheta(): Float {        val us = binding.etU.text.toString().toFloat()        return altoMocheta() - (us)    }    private fun uSuperior(): Float {        return mPuentes1()    }    private fun uSuperior2(): Float {        return mPuentes2()    }    @SuppressLint("SetTextI18n")    private fun uTexto() {        val anchoTexto = binding.etAncho.text?.toString() ?: ""        val ancho = if (anchoTexto.isEmpty()) 120f else anchoTexto.toFloatOrNull() ?: 120f        val altoTexto = binding.etAlto.text?.toString() ?: ""        val alto = if (altoTexto.isEmpty()) 200f else altoTexto.toFloatOrNull() ?: 200f        val hojaTexto = binding.etHoja.text?.toString() ?: ""        val hoja = if (hojaTexto.isEmpty()) 0f else hojaTexto.toFloatOrNull() ?: 0f        val us = binding.etU.text?.toString()?.toFloatOrNull() ?: 1.5f        val divisManual = binding.etPartes.text?.toString()?.toIntOrNull() ?: 0        val cruce = cruce()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val altoHoja = NovaCalculos.altoHoja(alto, hoja)        val nFijos = NovaCalculos.nFijos(divisiones)        val fijoUParante = NovaCalculos.fijoUParante(divisiones)        val mochetaUParante = NovaCalculos.mochetaUParante(divisiones)        val nPuentes = NovaCalculos.nPuentes(divisiones)        val uFijos = NovaCalculos.uFijos(ancho, divisiones, cruce)        val uParante = altoHoja - (us + 0.2f)        val altoMocheta = NovaCalculos.altoMocheta(alto, altoHoja, tubo)        val uMocheta = altoMocheta - us        val mPuentes1 = NovaCalculos.mPuentes1(ancho, divisiones)        val uSuperior = mPuentes1        val mPuentes2 = NovaCalculos.mPuentes2(ancho, divisiones)        val uSuperior2 = mPuentes2        val valorFinal = if (puente == "MÃºltiple" || puente == "gorrito") 1 else 2        // Configurar etiqueta U        binding.tvU.text = when (us) {            1f -> "u-3/8"            1.5f -> "u-13"            else -> "u-${NovaCalculos.df1(us)}"        }        // Calcular texto U bÃƒÂ¡sico (simplificado)        binding.txU.text = if (alto > altoHoja && us != 0F) {            when {                divisiones == 1 -> "${NovaCalculos.df1(uFijos)} = 2\n" +                        "${NovaCalculos.df1(uParante)} = 2\n${NovaCalculos.df1(uMocheta)} = $mochetaUParante"                divisiones == 10 || divisiones == 14 -> "${NovaCalculos.df1(uFijos)} = $nFijos\n" +                        "${NovaCalculos.df1(uParante)} = $fijoUParante\n${NovaCalculos.df1(uMocheta)} = $mochetaUParante\n" +                        "${NovaCalculos.df1(uSuperior)} = ${nPuentes - 1}\n${NovaCalculos.df1(uSuperior2)} = ${(nPuentes - 2) * valorFinal}"                else -> "${NovaCalculos.df1(uFijos)} = $nFijos\n${NovaCalculos.df1(uParante)} = $fijoUParante\n" +                        "${NovaCalculos.df1(uMocheta)} = $mochetaUParante\n${NovaCalculos.df1(uSuperior)} = ${nPuentes * valorFinal}"            }        } else if (alto > altoHoja && us == 0F) {            when {                divisiones == 1 -> "${NovaCalculos.df1(uFijos)} = 2"                divisiones == 10 || divisiones == 14 -> "${NovaCalculos.df1(uFijos)} = $nFijos\n${NovaCalculos.df1(uSuperior)} = ${nPuentes - 1}\n${NovaCalculos.df1(uSuperior2)} = ${nPuentes - 2}"                else -> "${NovaCalculos.df1(uFijos)} = $nFijos\n${NovaCalculos.df1(uSuperior)} = $nPuentes"            }        } else if (alto <= altoHoja && us != 0F) {            when {                divisiones == 1 -> "${NovaCalculos.df1(uFijos)} = 2\n${NovaCalculos.df1(uParante)} = 2"                else -> "${NovaCalculos.df1(uFijos)} = $nFijos\n${NovaCalculos.df1(uParante)} = $fijoUParante"            }        } else {            when {                divisiones == 1 -> "${NovaCalculos.df1(uFijos)} = 2"                else -> "${NovaCalculos.df1(uFijos)} = $nFijos"            }        }    }    private fun portafelpa(): Float {        return altoHoja() - 1.6f    }    private fun hache(): Float {        return uFijos()    }    private fun te(): Float {        val us = binding.etU.text.toString().toFloat()        return altoMocheta() - (us)    }    private fun nTe(): Int {        return when {            divisiones() % 2 != 0 || divisiones() < 6 -> nVidriosMoch() - 1            divisiones() == 6 || divisiones() == 8 -> nVidriosMoch() - 2            divisiones() == 10 || divisiones() == 14 -> (nVidriosMoch() - 2) + (nVidriosMoch2() - 1)            divisiones() == 12 -> (nVidriosMoch() - 3)            else -> { 0 }        }    }    private fun parante(): Float {        return binding.etAlto.text.toString().toFloat()    }    private fun vidriosFijos(): String {        val alto = altoHoja()        val us = binding.etU.text.toString().toFloat()        val holgura = if (us == 0f) { 1f } else { 0.2f }        return when {            divisiones() == 1 -> { "${df1(uFijos() - 0.6f)} x ${df1(alto - (us + holgura))} = " +                    "${nFijos()}" }            divisiones() < 5 -> { "${df1(uFijos() - 0.4f)} x ${df1(alto - (us + holgura))} = " +                    "${nFijos()}" }            divisiones() % 2 == 0 && divisiones() < 14 -> { "${df1(uFijos() - 0.4f)} x " +                    "${df1(alto - (us + holgura))} = ${nFijos()}" }            divisiones() == 14 -> { "${df1(uFijos() - 0.4f)} x ${df1(alto - (us + holgura))} = 6\n" +                    "${df1(uFijos())} x ${df1(alto - (us + holgura))} = 2" }            else -> { "${df1(uFijos() - 0.4f)} x ${df1(alto - (us + holgura))} = 2\n" +                    "${df1(uFijos())} x ${df1(alto - (us + holgura))}= ${nFijos() - 2}" }        }    }    private fun vidrioCorre(): String {        return "${df1(hache() - 1.4f)} x ${df1(altoHoja() - 3.5f)} = ${nCorredizas()}"    }    private fun vidrioMocheta(): String {        return if (divisiones() == 1) { df1(vAnchoMocheta1()) +                " x ${df1(vAltoMocheta())} = ${anchMota()}" }        else if (divisiones() == 10 || divisiones() == 14) { "${df1(vAnchoMocheta1())} x ${            df1(vAltoMocheta())} = ${nVidriosMoch()}\n" +                "${df1(vidrioAnchoMocheta2())} x ${                    df1(vAltoMocheta())} = ${nVidriosMoch2()}" }        else { "${df1(vAnchoMocheta1())} x ${            df1(vAltoMocheta())} = ${nVidriosMoch()}" }    }    private fun vAltoMocheta(): Float {        val us = binding.etU.text.toString().toFloat()        val holgura = 0.36f        return if (puente == "MÃºltiple" || puente == "gorrito") {            altoMocheta() - holgura        } else { altoMocheta() - us - holgura }    }    private fun vAnchoMocheta1(): Float {        val holgura = if (divisiones() % 2 == 0) { ((nVidriosMoch() + 1) * 0.36f) / 2 } else { (nVidriosMoch() + 1) * 0.36f }        return (mPuentes1() - holgura) / anchMota()    }    private fun vidrioAnchoMocheta2(): Float {        val holgura = (nVidriosMoch2() + 1) * 0.36f        return (mPuentes2() - holgura) / anchMota2()    }    private fun nVidriosMoch(): Int {        return if (divisiones() == 2 && divisiones() == 4) { anchMota() }        else if (divisiones() % 2 == 0 && divisiones() >= 6 && divisiones() < 10) { anchMota() * 2 }        else if (divisiones() == 12) { anchMota() * 3 }        else if (divisiones() == 10 || divisiones() == 14) { anchMota() * 2 }        else { anchMota() }    }    private fun nVidriosMoch2(): Int {        return if (divisiones() == 10 || divisiones() == 14) { anchMota2() }        else { 1 }    }    @SuppressLint("SetTextI18n")    private fun vidriosTexto() {        val ancho = ancho()        val alto = alto()        val hoja = altoHoja()        val us = binding.etU.text.toString().toFloat()        val divisManual = divisiones()        val cruce = cruce()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val altoHoja = NovaCalculos.altoHoja(alto, hoja)        val nFijos = NovaCalculos.nFijos(divisiones)        val nCorredizas = NovaCalculos.nCorredizas(divisiones)        val uFijos = NovaCalculos.uFijos(ancho, divisiones, cruce)        // Vidrios fijos        val holgura = if (us == 0f) 1f else 0.2f        val vidriosFijos = when {            divisiones == 1 -> "${NovaCalculos.df1(uFijos - 0.6f)} x ${NovaCalculos.df1(altoHoja - (us + holgura))} = $nFijos"            divisiones < 5 -> "${NovaCalculos.df1(uFijos - 0.4f)} x ${NovaCalculos.df1(altoHoja - (us + holgura))} = $nFijos"            divisiones % 2 == 0 && divisiones < 14 -> "${NovaCalculos.df1(uFijos - 0.4f)} x " +                    "${NovaCalculos.df1(altoHoja - (us + holgura))} = $nFijos"            divisiones == 14 -> "${NovaCalculos.df1(uFijos - 0.4f)} x " +                    "${NovaCalculos.df1(altoHoja - (us + holgura))} = 6\n${NovaCalculos.df1(uFijos)} x " +                    "${NovaCalculos.df1(altoHoja - (us + holgura))} = 2"            else -> "${NovaCalculos.df1(uFijos - 0.4f)} x ${NovaCalculos.df1(altoHoja - (us + holgura))} = 2" +                    "\n${NovaCalculos.df1(uFijos)} x ${NovaCalculos.df1(altoHoja - (us + holgura))} = ${nFijos - 2}"        }        // Vidrios corredizos        val vidrioCorre = "${NovaCalculos.df1(uFijos - 1.4f)} x ${NovaCalculos.df1(altoHoja - 3.5f)} = $nCorredizas"        // Vidrios mocheta (simplificado)        val altoMocheta = NovaCalculos.altoMocheta(alto, altoHoja, tubo)        val holguraMocheta = 0.36f        val vAltoMocheta = if (puente == "MÃºltiple" || puente == "gorrito") {            altoMocheta - holguraMocheta        } else {            altoMocheta - us - holguraMocheta        }        val mPuentes1 = NovaCalculos.mPuentes1(ancho, divisiones)        val anchMota = NovaCalculos.anchMota(mPuentes1)        val vAnchoMocheta = (mPuentes1 - ((anchMota + 1) * 0.36f)) / anchMota        val vidrioMocheta = "${NovaCalculos.df1(vAnchoMocheta)} x ${NovaCalculos.df1(vAltoMocheta)} = $anchMota"        // Texto final bÃ¡sico (simplificado sin tipos)        binding.txV.text = if (hoja < alto) {            if (divisiones > 1) {                "$vidriosFijos\n$vidrioCorre\n$vidrioMocheta"            } else {                "$vidriosFijos\n$vidrioMocheta"            }        } else {            if (divisiones > 1) {                "$vidriosFijos\n$vidrioCorre"            } else {                vidriosFijos            }        }    }    @SuppressLint("SetTextI18n")    private fun otrosAluminios() {        val anchoTexto = binding.etAncho.text?.toString() ?: ""        val ancho = if (anchoTexto.isEmpty()) 120f else anchoTexto.toFloatOrNull() ?: 120f        val altoTexto = binding.etAlto.text?.toString() ?: ""        val alto = if (altoTexto.isEmpty()) 200f else altoTexto.toFloatOrNull() ?: 200f        val hojaTexto = binding.etHoja.text?.toString() ?: ""        val hoja = if (hojaTexto.isEmpty()) 0f else hojaTexto.toFloatOrNull() ?: 0f        val divisManual = binding.etPartes.text?.toString()?.toIntOrNull() ?: 0        val cruce = cruce()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val altoHoja = NovaCalculos.altoHoja(alto, hoja)        val nCorredizas = NovaCalculos.nCorredizas(divisiones)        val nPuentes = NovaCalculos.nPuentes(divisiones)        val mPuentes1 = NovaCalculos.mPuentes1(ancho, divisiones)        val mPuentes2 = NovaCalculos.mPuentes2(ancho, divisiones)        val uFijos = NovaCalculos.uFijos(ancho, divisiones, cruce)        val portafelpa = NovaCalculos.portafelpa(altoHoja)        val divDePortas = NovaCalculos.divDePortas(divisiones, nCorredizas)        // MÃƒÅ¡LTIPLE/PUENTE        binding.txP.text = when {            divisiones in 6..12 && divisiones % 2 == 0 -> {                "${NovaCalculos.df1(mPuentes1)} = $nPuentes\n${NovaCalculos.df1(alto)} = ${nPuentes - 1}"            }            divisiones == 14 -> {                "${NovaCalculos.df1(mPuentes1)} = ${nPuentes - 1}\n" +                        "${NovaCalculos.df1(mPuentes2)} = ${nPuentes - 2}\n" +                        "${NovaCalculos.df1(alto)} = ${nPuentes - 1}"            }            else -> {                "${NovaCalculos.df1(mPuentes1)} = $nPuentes"            }        }        // RIEL        binding.txR.text = if (divisiones == 1 || nCorredizas == 0) {            ""        } else {            NovaPerfilesHelper.calcularRieles(alto, hoja, ancho, mPuentes1, mPuentes2, nPuentes, divisiones)        }        // TUBO        binding.txT.text = if (alto > altoHoja) {            "${NovaCalculos.df1(ancho)} = 1"        } else {            ""        }        // PORTAFELPA        binding.txPf.text = "${NovaCalculos.df1(portafelpa)} = $divDePortas"        // TEE        val altoMocheta = NovaCalculos.altoMocheta(alto, altoHoja, tubo)        val us = binding.etU.text?.toString()?.toFloatOrNull() ?: 1.5f        val te = altoMocheta - us        binding.txTe.text = if (te > 0) {            "${NovaCalculos.df1(te)} = ${nCorredizas}"        } else {            ""        }        // ÃƒÂNGULO TOPE        binding.txTo.text = if (divisiones == 2) {            "${NovaCalculos.df1(altoHoja - 0.9f)} = 1"        } else {            ""        }        // HACHE        binding.txH.text = if (nCorredizas > 0) {            "${NovaCalculos.df1(uFijos)} = $nCorredizas"        } else {            ""        }    }    private fun ancho(): Float {            val anchoTexto = binding.etAncho.text.toString().toFloat()            return anchoTexto    }    private fun ancho2(): Float {        return binding.etAncho2.text.toString().toFloat()    }    private fun alto(): Float {        return binding.etAlto.text.toString().toFloat()    }    private fun altoMocheta(): Float {        val alto = alto().toFloat()        val hoja = altoHoja()        return alto - (hoja + tubo)    }    private fun anchMota(): Int {        return when (mPuentes1()) {            in 0.0..180.0 -> 1            in 180.0..360.0 -> 2            in 360.0..540.0 -> 3            in 540.0..720.0 -> 4            in 720.0..900.0 -> 5            else -> 0        }    }    private fun anchMota2(): Int {        return when (mPuentes2()) {            in 0.0..180.0 -> 1            in 180.0..360.0 -> 2            in 360.0..540.0 -> 3            in 540.0..720.0 -> 4            in 720.0..900.0 -> 5            else -> 0        }    }    private fun altoHoja(): Float {        val alto = alto()        val hoja = binding.etHoja.text.toString().toFloat()        val corre = if (hoja >= alto) { alto } else { hoja }        return if (hoja == 0f) { alto / 7 * 5 } else { corre }    }    private fun siNoMoch(): Int {        val alto = binding.etAlto.text.toString().toFloat()        val hoja = binding.etHoja.text.toString().toFloat()        return if (hoja >= alto) { 0 } else { 1 }    }    private fun diviMocheta(x: Float): Int {        val n = binding.etNmochetas.text.toString().toInt()        require(x > 0) { "El valor debe ser positivo y mayor que cero." }        return if (n == 0) {            ceil(x / 240.0).toInt()        } else {            n        }    }    private fun divisiones(): Int {        return try {            val anchoTexto = binding.etAncho.text?.toString() ?: ""            val ancho = if (anchoTexto.isEmpty()) 120f else anchoTexto.toFloatOrNull() ?: 120f            val divisTexto = binding.etPartes.text?.toString() ?: ""            val divis = if (divisTexto.isEmpty()) 0 else divisTexto.toIntOrNull() ?: 0            // Usar EXACTAMENTE igual que NovaIna (sin tipos)            NovaCalculos.divisiones(ancho, divis)        } catch (e: Exception) {            1        }    }    private fun divDePortas(): Int {        return when (divisiones()) {            1 -> 0            2, 4, 8, 12 -> { nCorredizas() * 3 }            14 -> { (nCorredizas() * 4) - 2 }            else -> { nCorredizas() * 4 }        }    }    private fun nFijos(): Int {        return when (texto) {            "nn" -> when (divisiones()) {                1 -> 1                2 -> 1                3 -> 2                4 -> 2                5 -> 3                6 -> 4                7 -> 4                8 -> 4                9 -> 5                10 -> 6                11 -> 6                12 -> 6                13 -> 7                14 -> 8                15 -> 8                else -> 0            }            "ncc" -> 0            "n3c" -> 0            "ncfc" -> 1            else -> { 0 }        }    }    private fun nCorredizas(): Int {        return when (texto) {            "nn" -> when (divisiones()) {                1 -> 0                2 -> 1                3 -> 1                4 -> 2                5 -> 2                6 -> 2                7 -> 3                8 -> 4                9 -> 4                10 -> 4                11 -> 5                12 -> 6                13 -> 6                14 -> 6                15 -> 7                else -> 0            }            "ncc" -> 2            "n3c" -> 3            "ncfc" -> 2            else -> { 0 }        }    }    private fun fijoUParante(): Int {        return when (divisiones()) {            1 -> 2            2 -> 1            3 -> 2            4 -> 2            5 -> 2            6 -> 4            7 -> 2            8 -> 4            9 -> 2            10 -> 6            11 -> 2            12 -> 6            13 -> 2            14 -> 6            15 -> 2            else -> 0        }    }    private fun mochetaUParante(): Int {        return when (divisiones()) {            1 -> 2            2 -> 2            3 -> 2            4 -> 2            5 -> 2            7 -> 2            9 -> 2            11 -> 2            13 -> 2            15 -> 2            6 -> 4            8 -> 4            10 -> 6            12 -> 6            14 -> 6            else -> 0        }    }    private fun nPuentes(): Int {        return when (divisiones()) {            1 -> 1            2 -> 1            3 -> 1            4 -> 1            5 -> 1            7 -> 1            9 -> 1            11 -> 1            13 -> 1            15 -> 1            6 -> 2            8 -> 2            10 -> 3            12 -> 3            14 -> 3            else -> 0        }    }    private fun mPuentes1(): Float {        val ancho = binding.etAncho.text.toString().toFloat()        val parantes = 2.5f        return when (divisiones()) {            1 -> ancho            2 -> ancho            3 -> ancho            4 -> ancho            5 -> ancho            7 -> ancho            9 -> ancho            11 -> ancho            13 -> ancho            15 -> ancho            6 -> (ancho - parantes) / 2            8 -> (ancho - parantes) / 2            10 -> (ancho - (2 * parantes)) / divisiones() * 3            12 -> (ancho - (2 * parantes)) / 3            14 -> (ancho - (2 * parantes)) / divisiones() * 5            else -> 0f        }    }    private fun mPuentes2(): Float {        val ancho = binding.etAncho.text.toString().toFloat()        val parantes = 2.5f        return when (divisiones()) {            10 -> (ancho - (2 * parantes)) / divisiones() * 4            14 -> (ancho - (2 * parantes)) / divisiones() * 4            else -> 0f        }    }    private fun spinnerTubo() {        val spinnerOptions = listOf(            SpinnerTubos(R.drawable.ma_multi, "MÃƒÂºltiple", 1.5f),            SpinnerTubos(R.drawable.ma_multi, "tubo 2 x 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi, "tubo 2 3|8 x 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi, "tubo.c 1 1|2", 3.8f),            SpinnerTubos(R.drawable.ma_multi, "tubo.c 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi, "paflon 1 1|2", 3.8f),            SpinnerTubos(R.drawable.ma_multi, "paflon 1", 2.5f),            SpinnerTubos(R.drawable.ma_multi, "tubo 2 x 2", 5.0f),            SpinnerTubos(R.drawable.ma_multi, "gorrito", 2.5f)        )        val adapter = AdaptadorSpinner(this, spinnerOptions)        binding.spinner.adapter = adapter        binding.spinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {            override fun onItemSelected(                parent: AdapterView<*>?,                view: View?,                position: Int,                id: Long            ) {                val selectedOption = spinnerOptions[position]                tubo = selectedOption.valor                puente = selectedOption.text                Toast.makeText(                    this@NovaApa,                    "Seleccionado: ${selectedOption.text}, Valor: ${selectedOption.valor}",                    Toast.LENGTH_SHORT                ).show()            }            override fun onNothingSelected(parent: AdapterView<*>?) {            }        }    }    private fun puntosU(): String {        val ancho = binding.etAncho.text.toString().toFloat()        val divisManual = binding.etPartes.text.toString().toInt()        val cruce = cruce()        val divisiones = NovaCalculos.divisiones(ancho, divisManual)        val partes = NovaCalculos.uFijos(ancho, divisiones, cruce)        val punto1 = NovaCalculos.df1((partes * 2) - cruce * 2).toFloat()        val punto2 = NovaCalculos.df1((partes * 4) - cruce * 4).toFloat()        val punto3 = NovaCalculos.df1((partes * 6) - cruce * 6).toFloat()        return when (divisiones) {            5, 6 -> NovaCalculos.df1(((partes * 2) - cruce * 2))            8, 12 -> NovaCalculos.df1(((partes * 3) - cruce * 2))            7, 10, 14 -> "${NovaCalculos.df1(punto1)}_${NovaCalculos.df1(punto2)}"            9, 11, 13, 15 -> "${NovaCalculos.df1(punto1)}_${NovaCalculos.df1(punto2)}_${NovaCalculos.df1(punto3)}"            else -> ""        }    }    private fun mostrarLySpinner() {        binding.lySpinner.alpha = 0f        binding.lySpinner.visibility = View.VISIBLE        binding.lySpinner.animate()            .alpha(1f)            .setDuration(300)            .start()    }    private fun ocultarLySpinner() {        binding.lySpinner.animate()            .alpha(0f)            .setDuration(300)            .withEndAction {                binding.lySpinner.visibility = View.GONE            }            .start()    }    data class SpinnerTubos(        val imageResId: Int,        val text: String,        val valor: Float    )    class AdaptadorSpinner(        context: Context,        private val options: List<SpinnerTubos>    ) : ArrayAdapter<SpinnerTubos>(context, 0, options) {        override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {            return createItemView(position, convertView, parent)        }        override fun getDropDownView(position: Int, convertView: View?, parent: ViewGroup): View {            return createItemView(position, convertView, parent)        }        private fun createItemView(position: Int, convertView: View?, parent: ViewGroup): View {            val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.mo_tubo, parent, false)            val imageViewOption = view.findViewById<ImageView>(R.id.imgTubo)            val textViewOption = view.findViewById<TextView>(R.id.txNombre)            val spinnerOption = options[position]            imageViewOption.setImageResource(spinnerOption.imageResId)            textViewOption.text = spinnerOption.text            return view        } }    // FUNCIONES PARA ARCHIVAR    private fun obtenerPrefijo(): String {        return "NA" // NovaApa - en el futuro puede variar    }    private fun archivarMapas() {        // âœ… SIEMPRE limpiar y cargar el Map del proyecto activo actual        val proyectoActivo = ProyectoManager.getProyectoActivo()        if (proyectoActivo != null) {            val mapExistente = MapStorage.cargarProyecto(this, proyectoActivo)            mapListas.clear() // Limpiar datos anteriores            if (mapExistente != null) {                mapListas.putAll(mapExistente) // Cargar datos del proyecto correcto            }            // Si mapExistente es null, mapListas queda vacÃ­o (correcto para proyecto nuevo)        }        val prefijo = obtenerPrefijo()        val siguienteNumero = ProyectoManager.obtenerSiguienteContadorPorPrefijo(this, prefijo)        val identificadorPaquete = "v${siguienteNumero}${prefijo}"        if (esValido(binding.lyReferencias)) {            ListaCasilla.procesarReferenciasConPrefijo(this, binding.tvReferencias, binding.txReferencias, mapListas, identificadorPaquete)        }        if (esValido(binding.u13layout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvU, binding.txU, mapListas, identificadorPaquete)        }        if (esValido(binding.mulLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvP, binding.txP, mapListas, identificadorPaquete)        }        if (esValido(binding.fcLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvFc, binding.txFc, mapListas, identificadorPaquete)        }        if (esValido(binding.rielLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvR, binding.txR, mapListas, identificadorPaquete)        }        if (esValido(binding.tuboLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvT, binding.txT, mapListas, identificadorPaquete)        }        if (esValido(binding.portaLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvPf, binding.txPf, mapListas, identificadorPaquete)        }        if (esValido(binding.tLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvTe, binding.txTe, mapListas, identificadorPaquete)        }        if (esValido(binding.angLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvTo, binding.txTo, mapListas, identificadorPaquete)        }        if (esValido(binding.hLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvH, binding.txH, mapListas, identificadorPaquete)        }        if (esValido(binding.vidriosLayout)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvV, binding.txV, mapListas, identificadorPaquete)        }        if (esValido(binding.lyClient)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvC, binding.txC, mapListas, identificadorPaquete)        }        if (esValido(binding.lyAncho)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvAncho, binding.txAncho, mapListas, identificadorPaquete)        }        if (esValido(binding.lyAlto)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvAlto, binding.txAlto, mapListas, identificadorPaquete)        }        if (esValido(binding.lyPuente)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvPuente, binding.txPuente, mapListas, identificadorPaquete)        }        if (esValido(binding.lyDivisiones)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvDivisiones, binding.txDivisiones, mapListas, identificadorPaquete)        }        if (esValido(binding.lyFijos)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvFijos, binding.txFijos, mapListas, identificadorPaquete)        }        if (esValido(binding.lyCorredizas)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvCorredizas, binding.txCorredizas, mapListas, identificadorPaquete)        }        if (esValido(binding.lyDiseno)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvDiseno, binding.txDiseno, mapListas, identificadorPaquete)        }        if (esValido(binding.lyGrados)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvGrados, binding.txGrados, mapListas, identificadorPaquete)        }        if (esValido(binding.lyTipo)) {            ListaCasilla.procesarArchivarConPrefijo(this, binding.tvTipo, binding.txTipo, mapListas, identificadorPaquete)        }        ProyectoManager.actualizarContadorPorPrefijo(this, prefijo, siguienteNumero)        MapStorage.guardarMap(this, mapListas)        ProyectoUIHelper.actualizarVisorProyectoActivo(this, binding.tvProyectoActivo)        binding.txPr.text = mapListas.toString()        Toast.makeText(this, "Datos archivados como $identificadorPaquete en proyecto: ${ProyectoManager.getProyectoActivo()}", Toast.LENGTH_SHORT).show()    }}